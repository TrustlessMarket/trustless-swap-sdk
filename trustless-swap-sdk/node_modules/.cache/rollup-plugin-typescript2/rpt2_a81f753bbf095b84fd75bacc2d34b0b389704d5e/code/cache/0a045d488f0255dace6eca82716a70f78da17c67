{"code":"// This file contains code to easily connect to and get information from a wallet on chain\r\nimport { BigNumber, ethers } from 'ethers';\r\nimport JSBI from 'jsbi';\r\nimport { CurrentConfig, } from './config';\r\nimport { ERC20_ABI, MAX_FEE_PER_GAS, MAX_PRIORITY_FEE_PER_GAS, WETH_ABI } from './constants';\r\nimport { getProvider, getWalletAddress, sendTransaction } from './providers';\r\nimport { toReadableAmount } from './utils1';\r\nexport async function getCurrencyBalance(provider, address, currency) {\r\n    // Handle ETH directly\r\n    if (currency.isNative || currency.address.toLowerCase() == CurrentConfig.TC_CONTRACT_ADDRESS.toLowerCase()) {\r\n        return ethers.utils.formatEther(await provider.getBalance(address));\r\n    }\r\n    // Get currency otherwise\r\n    const ERC20Contract = new ethers.Contract(currency.address, ERC20_ABI, provider);\r\n    const balance = await ERC20Contract.balanceOf(address);\r\n    const decimals = await ERC20Contract.decimals();\r\n    // Format with proper units (approximate)\r\n    return toReadableAmount(balance, decimals);\r\n}\r\nexport async function getCurrencyApproveRouter(provider, address, currency) {\r\n    // Handle ETH directly\r\n    if (currency.isNative) {\r\n        return -1;\r\n    }\r\n    console.log(\"address\", address);\r\n    // Get currency otherwise\r\n    const ERC20Contract = new ethers.Contract(currency.address, ERC20_ABI, provider);\r\n    const amountAprrove = await ERC20Contract.allowance(address, CurrentConfig.SWAP_ROUTER_ADDRESS);\r\n    console.log(\"address1\", address);\r\n    const decimals = await ERC20Contract.decimals();\r\n    console.log(\"amountAprrove\", amountAprrove);\r\n    // Format with proper units (approximate)\r\n    return Number(toReadableAmount(amountAprrove, decimals));\r\n}\r\n// wraps ETH (rounding up to the nearest ETH for decimal places)\r\nexport async function wrapETH(eth) {\r\n    const provider = getProvider();\r\n    const address = getWalletAddress();\r\n    if (!provider || !address) {\r\n        throw new Error('Cannot wrap ETH without a provider and wallet address');\r\n    }\r\n    const wethContract = new ethers.Contract(CurrentConfig.WETH_CONTRACT_ADDRESS, WETH_ABI, provider);\r\n    const transaction = {\r\n        data: wethContract.interface.encodeFunctionData('deposit'),\r\n        value: BigNumber.from(Math.ceil(eth))\r\n            .mul(JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(18)).toString())\r\n            .toString(),\r\n        from: address,\r\n        to: CurrentConfig.WETH_CONTRACT_ADDRESS,\r\n        maxFeePerGas: MAX_FEE_PER_GAS,\r\n        maxPriorityFeePerGas: MAX_PRIORITY_FEE_PER_GAS,\r\n    };\r\n    await sendTransaction(transaction);\r\n}\r\n// unwraps ETH (rounding up to the nearest ETH for decimal places)\r\nexport async function unwrapETH(eth) {\r\n    const provider = getProvider();\r\n    const address = getWalletAddress();\r\n    if (!provider || !address) {\r\n        throw new Error('Cannot unwrap ETH without a provider and wallet address');\r\n    }\r\n    const wethContract = new ethers.Contract(CurrentConfig.WETH_CONTRACT_ADDRESS, WETH_ABI, provider);\r\n    const transaction = {\r\n        data: wethContract.interface.encodeFunctionData('withdraw', [\r\n            BigNumber.from(Math.ceil(eth))\r\n                .mul(JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(18)).toString())\r\n                .toString(),\r\n        ]),\r\n        from: address,\r\n        to: CurrentConfig.WETH_CONTRACT_ADDRESS,\r\n        maxFeePerGas: MAX_FEE_PER_GAS,\r\n        maxPriorityFeePerGas: MAX_PRIORITY_FEE_PER_GAS,\r\n    };\r\n    await sendTransaction(transaction);\r\n}\r\n/*\r\nexport async function buyTCFee(need_amount_tc = '0.1', tokenType?: TokenType){\r\n  const tokenAddress =\r\n      tokenType === 'ETH' ? TOKEN_ADDRESS.ETH_ADDRESS_L2 : BTC_L2_ADDRESS;\r\n  let [tokenBuyPrice, chainNetwork, userAmountBTC] = await Promise.all([\r\n    this.getBTCPrice(),\r\n    this.gameWalletProvider.gameWallet?.provider.getNetwork(),\r\n    this.contract\r\n        .getERC20Contract(tokenAddress)\r\n        .connect(this.wallet)\r\n        .balanceOf(this.wallet.address),\r\n  ]);\r\n\n  if (tokenType === 'ETH') {\r\n    tokenBuyPrice = BigNumber.from('145000000000000000000');\r\n  }\r\n  const amountApprove = await this.contract\r\n      .getERC20Contract(tokenAddress)\r\n      .allowance(this.wallet.address, ALPHA_KEY_FACTORY_ADDRESS);\r\n  if (BigNumber.from(amountApprove).lt(parseEther('1'))) {\r\n    const txApprove = await this.contract\r\n        .getERC20Contract(tokenAddress)\r\n        .connect(this.wallet)\r\n        .approve(ALPHA_KEY_FACTORY_ADDRESS, ethers.constants.MaxUint256);\r\n    await txApprove.wait();\r\n  }\r\n\n  const estimateBTCAmount = parseEther(need_amount_tc)\r\n      .mul(parseEther(tokenType === 'ETH' ? '0.1' : '1'))\r\n      .div(tokenBuyPrice);\r\n\n  let amountBTC = estimateBTCAmount;\r\n\n  if (BigNumber.from(estimateBTCAmount).gt(userAmountBTC)) {\r\n    amountBTC = BigNumber.from(userAmountBTC).gt(estimateBTCAmount)\r\n        ? amountBTC\r\n        : userAmountBTC;\r\n  }\r\n\n  try {\r\n    const akf = this.contract.getAlphaKeysFactoryContract();\r\n    const nonce = BigNumber.from(ethers.utils.randomBytes(32));\r\n\n    const chainId = chainNetwork?.chainId as number;\r\n\n    const messagePack = ethers.utils.defaultAbiCoder.encode(\r\n        [\r\n          'address',\r\n          'uint256',\r\n          'uint256',\r\n          'address',\r\n          'uint256',\r\n          'uint256',\r\n          'uint256',\r\n        ],\r\n        [\r\n          akf.address,\r\n          chainId,\r\n          nonce,\r\n          this.wallet.address,\r\n          amountBTC,\r\n          tokenBuyPrice,\r\n          ethers.constants.MaxUint256,\r\n        ]\r\n    );\r\n\n    const messageHash = ethers.utils.keccak256(\r\n        ethers.utils.arrayify(messagePack)\r\n    );\r\n    const signature = await this.wallet.signMessage(\r\n        ethers.utils.arrayify(messageHash)\r\n    );\r\n\n    const data_hex = akf.interface.encodeFunctionData(\r\n        (tokenType === 'ETH' ? 'requestETH2TC' : 'requestTC') as any,\r\n        [\r\n          nonce,\r\n          this.wallet.address,\r\n          amountBTC,\r\n          tokenBuyPrice,\r\n          ethers.constants.MaxUint256,\r\n          signature,\r\n        ]\r\n    );\r\n    const result: any = await this.tradeAPI.sendTx({\r\n      contract_address: akf.address,\r\n      data_hex,\r\n    });\r\n    const r: any =\r\n        await this.gameWalletProvider.gameWallet?.provider.getTransaction(\r\n            result\r\n        );\r\n    await r.wait();\r\n    await this.assetContext.fetchAssets();\r\n    return;\r\n  } catch (error) {\r\n    errorLogger.report({\r\n      action: errorLogger.ERROR_LOGGER_TYPE.BUY_TC,\r\n      address: this.wallet.address,\r\n      error: JSON.stringify(error),\r\n      info: JSON.stringify({\r\n        userAmountBTC: userAmountBTC.toString(),\r\n        amountBTC: amountBTC.toString(),\r\n      }),\r\n    });\r\n    await this.getFaucet();\r\n    throw error;\r\n  }\r\n};\r\n\n\nexport async function estimateTCGasFee ({\r\n                                          type,\r\n                                          needFeeTC,\r\n                                        }: {\r\n  type: ETypes;\r\n  needFeeTC?: any;\r\n}) {\r\n  const _needFeeTC = ceil(needFeeTC || typeToFee[type]);\r\n  console.log('_needFeeTC', _needFeeTC, typeToFee[type]);\r\n\n  let isBuy = false;\r\n\n  try {\r\n    const [amount, amountBTC] = await Promise.all([\r\n      gameWalletProvider.gameWallet?.provider.getBalance(\r\n          gameWalletProvider.gameWallet.address\r\n      ),\r\n      contract\r\n          .getERC20Contract(BTC_L2_ADDRESS)\r\n          .connect(wallet)\r\n          .balanceOf(wallet.address),\r\n    ]);\r\n\n\n    console.log(\r\n        'aaaa',\r\n        amountBTC.toString(),\r\n        BigNumber.from(amountBTC).gt('0')\r\n    );\r\n\n    if (\r\n        BigNumber.from(amount?.toString()).lt(parseEther('0.0005')) &&\r\n        BigNumber.from(amountBTC).gt('0')\r\n    ) {\r\n      const amountApprove = await this.contract\r\n          .getERC20Contract(BTC_L2_ADDRESS)\r\n          .allowance(this.wallet.address, ALPHA_KEY_FACTORY_ADDRESS);\r\n\n      if (BigNumber.from(amountApprove).lt(parseEther('1'))) {\r\n        await this.getFaucet();\r\n        const txApprove = await this.contract\r\n            .getERC20Contract(BTC_L2_ADDRESS)\r\n            .connect(this.wallet)\r\n            .approve(ALPHA_KEY_FACTORY_ADDRESS, ethers.constants.MaxUint256);\r\n        await txApprove.wait();\r\n        isBuy = true;\r\n      }\r\n    }\r\n\n\n    const gasPrice = await this.contract.provider?.getGasPrice();\r\n    const gasFee = new NBigNumber(_needFeeTC).multipliedBy(\r\n        gasPrice?.toString() as string\r\n    );\r\n    console.log(\r\n        'gasFee',\r\n        gasFee.toString(),\r\n        BigNumber.from(amount?.toString()).lt(gasFee.toString()),\r\n        amount?.toString()\r\n    );\r\n\n    if (\r\n        BigNumber.from(amount?.toString()).lt(parseEther('0.001')) ||\r\n        BigNumber.from(amount?.toString()).lt(gasFee.toString())\r\n    ) {\r\n      await this.buyTCFee(this.MIN_BUY_TC);\r\n      isBuy = true;\r\n    }\r\n  } catch (error) {\r\n    console.log('error', error);\r\n\n    isBuy = false;\r\n    throw error;\r\n  }\r\n\n  return isBuy;\r\n};\r\n*/ \r\n//# sourceMappingURL=wallet.js.map","references":["/Users/macbookpro/trustless-computer/trustless-swap-sdk/trustless-swap-sdk/src/entities/currency.ts","/Users/macbookpro/trustless-computer/trustless-swap-sdk/trustless-swap-sdk/node_modules/ethers/lib/index.d.ts","/Users/macbookpro/trustless-computer/trustless-swap-sdk/trustless-swap-sdk/node_modules/ethers/lib/index.d.ts","/Users/macbookpro/trustless-computer/trustless-swap-sdk/trustless-swap-sdk/node_modules/jsbi/jsbi.d.ts","/Users/macbookpro/trustless-computer/trustless-swap-sdk/trustless-swap-sdk/src/config.ts","/Users/macbookpro/trustless-computer/trustless-swap-sdk/trustless-swap-sdk/src/constants.ts","/Users/macbookpro/trustless-computer/trustless-swap-sdk/trustless-swap-sdk/src/providers.ts","/Users/macbookpro/trustless-computer/trustless-swap-sdk/trustless-swap-sdk/src/utils1.ts"],"map":"{\"version\":3,\"file\":\"wallet.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../src/wallet.ts\"],\"names\":[],\"mappings\":\"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\"}","dts":{"name":"/Users/macbookpro/trustless-computer/trustless-swap-sdk/trustless-swap-sdk/wallet.d.ts","writeByteOrderMark":false,"text":"import { Currency } from './entities/currency';\r\nimport { providers } from 'ethers';\r\nexport declare function getCurrencyBalance(provider: providers.Provider, address: string, currency: Currency): Promise<string>;\r\nexport declare function getCurrencyApproveRouter(provider: providers.Provider, address: string, currency: Currency): Promise<number>;\r\nexport declare function wrapETH(eth: number): Promise<void>;\r\nexport declare function unwrapETH(eth: number): Promise<void>;\r\n"}}
