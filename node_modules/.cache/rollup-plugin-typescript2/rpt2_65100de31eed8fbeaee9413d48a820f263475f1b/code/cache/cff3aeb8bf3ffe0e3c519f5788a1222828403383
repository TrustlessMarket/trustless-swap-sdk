{"code":"import invariant from 'tiny-invariant';\r\nimport { checkValidAddress, validateAndParseAddress } from '../utils/validateAndParseAddress';\r\nimport { BaseCurrency } from './baseCurrency';\r\n/**\r\n * Represents an ERC20 token with a unique address and some metadata.\r\n */\r\nexport class Token extends BaseCurrency {\r\n    /**\r\n     *\r\n     * @param chainId {@link BaseCurrency#chainId}\r\n     * @param address The contract address on the chain on which this token lives\r\n     * @param decimals {@link BaseCurrency#decimals}\r\n     * @param symbol {@link BaseCurrency#symbol}\r\n     * @param name {@link BaseCurrency#name}\r\n     * @param bypassChecksum If true it only checks for length === 42, startsWith 0x and contains only hex characters\r\n     */\r\n    constructor(chainId, address, decimals, symbol, name, bypassChecksum) {\r\n        super(chainId, decimals, symbol, name);\r\n        this.isNative = false;\r\n        this.isToken = true;\r\n        if (bypassChecksum) {\r\n            this.address = checkValidAddress(address);\r\n        }\r\n        else {\r\n            this.address = validateAndParseAddress(address);\r\n        }\r\n    }\r\n    /**\r\n     * Returns true if the two tokens are equivalent, i.e. have the same chainId and address.\r\n     * @param other other token to compare\r\n     */\r\n    equals(other) {\r\n        return other.isToken && this.chainId === other.chainId && this.address.toLowerCase() === other.address.toLowerCase();\r\n    }\r\n    /**\r\n     * Returns true if the address of this token sorts before the address of the other token\r\n     * @param other other token to compare\r\n     * @throws if the tokens have the same address\r\n     * @throws if the tokens are on different chains\r\n     */\r\n    sortsBefore(other) {\r\n        invariant(this.chainId === other.chainId, 'CHAIN_IDS');\r\n        invariant(this.address.toLowerCase() !== other.address.toLowerCase(), 'ADDRESSES');\r\n        return this.address.toLowerCase() < other.address.toLowerCase();\r\n    }\r\n    /**\r\n     * Return this token, which does not need to be wrapped\r\n     */\r\n    get wrapped() {\r\n        return this;\r\n    }\r\n}\r\n//# sourceMappingURL=token.js.map","references":["/Users/tuan/WebstormProjects/trustless-swap-sdk/node_modules/tiny-invariant/dist/tiny-invariant.d.ts","/Users/tuan/WebstormProjects/trustless-swap-sdk/src/utils/validateAndParseAddress.ts","/Users/tuan/WebstormProjects/trustless-swap-sdk/src/entities/baseCurrency.ts","/Users/tuan/WebstormProjects/trustless-swap-sdk/src/entities/currency.ts"],"map":"{\"version\":3,\"file\":\"token.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../src/entities/token.ts\"],\"names\":[],\"mappings\":\"AAAA,OAAO,SAAS,MAAM,gBAAgB,CAAA;AACtC,OAAO,EAAE,iBAAiB,EAAE,uBAAuB,EAAE,MAAM,kCAAkC,CAAA;AAC7F,OAAO,EAAE,YAAY,EAAE,MAAM,gBAAgB,CAAA;AAG7C;;GAEG;AACH,MAAM,OAAO,KAAM,SAAQ,YAAY;IASrC;;;;;;;;OAQG;IACH,YACE,OAAe,EACf,OAAe,EACf,QAAgB,EAChB,MAAe,EACf,IAAa,EACb,cAAwB;QAExB,KAAK,CAAC,OAAO,EAAE,QAAQ,EAAE,MAAM,EAAE,IAAI,CAAC,CAAA;QAzBxB,aAAQ,GAAU,KAAK,CAAA;QACvB,YAAO,GAAS,IAAI,CAAA;QAyBlC,IAAI,cAAc,EAAE;YAClB,IAAI,CAAC,OAAO,GAAG,iBAAiB,CAAC,OAAO,CAAC,CAAA;SAC1C;aAAM;YACL,IAAI,CAAC,OAAO,GAAG,uBAAuB,CAAC,OAAO,CAAC,CAAA;SAChD;IACH,CAAC;IAED;;;OAGG;IACI,MAAM,CAAC,KAAe;QAC3B,OAAO,KAAK,CAAC,OAAO,IAAI,IAAI,CAAC,OAAO,KAAK,KAAK,CAAC,OAAO,IAAI,IAAI,CAAC,OAAO,CAAC,WAAW,EAAE,KAAK,KAAK,CAAC,OAAO,CAAC,WAAW,EAAE,CAAA;IACtH,CAAC;IAED;;;;;OAKG;IACI,WAAW,CAAC,KAAY;QAC7B,SAAS,CAAC,IAAI,CAAC,OAAO,KAAK,KAAK,CAAC,OAAO,EAAE,WAAW,CAAC,CAAA;QACtD,SAAS,CAAC,IAAI,CAAC,OAAO,CAAC,WAAW,EAAE,KAAK,KAAK,CAAC,OAAO,CAAC,WAAW,EAAE,EAAE,WAAW,CAAC,CAAA;QAClF,OAAO,IAAI,CAAC,OAAO,CAAC,WAAW,EAAE,GAAG,KAAK,CAAC,OAAO,CAAC,WAAW,EAAE,CAAA;IACjE,CAAC;IAED;;OAEG;IACH,IAAW,OAAO;QAChB,OAAO,IAAI,CAAA;IACb,CAAC;CACF\"}","dts":{"name":"/Users/tuan/WebstormProjects/trustless-swap-sdk/entities/token.d.ts","writeByteOrderMark":false,"text":"import { BaseCurrency } from './baseCurrency';\r\nimport { Currency } from './currency';\r\n/**\r\n * Represents an ERC20 token with a unique address and some metadata.\r\n */\r\nexport declare class Token extends BaseCurrency {\r\n    readonly isNative: false;\r\n    readonly isToken: true;\r\n    /**\r\n     * The contract address on the chain on which this token lives\r\n     */\r\n    readonly address: string;\r\n    /**\r\n     *\r\n     * @param chainId {@link BaseCurrency#chainId}\r\n     * @param address The contract address on the chain on which this token lives\r\n     * @param decimals {@link BaseCurrency#decimals}\r\n     * @param symbol {@link BaseCurrency#symbol}\r\n     * @param name {@link BaseCurrency#name}\r\n     * @param bypassChecksum If true it only checks for length === 42, startsWith 0x and contains only hex characters\r\n     */\r\n    constructor(chainId: number, address: string, decimals: number, symbol?: string, name?: string, bypassChecksum?: boolean);\r\n    /**\r\n     * Returns true if the two tokens are equivalent, i.e. have the same chainId and address.\r\n     * @param other other token to compare\r\n     */\r\n    equals(other: Currency): boolean;\r\n    /**\r\n     * Returns true if the address of this token sorts before the address of the other token\r\n     * @param other other token to compare\r\n     * @throws if the tokens have the same address\r\n     * @throws if the tokens are on different chains\r\n     */\r\n    sortsBefore(other: Token): boolean;\r\n    /**\r\n     * Return this token, which does not need to be wrapped\r\n     */\r\n    get wrapped(): Token;\r\n}\r\n"}}
